### Полезные ссылки

[Habr - Управление памятью Java](https://habr.com/ru/amp/publications/549176/)  
[Stack Memory and Heap Space](https://www.baeldung.com/java-stack-heap)  
[What Is the Maximum Depth of the Java Call Stack?](https://www.baeldung.com/java-call-stack-max-depth)  
[JVM Garbage Collectors](https://www.baeldung.com/jvm-garbage-collectors)  

### Структура памяти в JAVA

![Структура памяти JAVA](/images/stackAndHeap.jpeg)  
![Диаграмма](/images/java-heap-stack-diagram.png)  

#### **_Память в Java делится на Stack и Heap._**

### **_Stack_**

**_Stack_** — это область памяти, доступ к которой организован в порядке LIFO.  
Стековая память в Java используется для распределения статической памяти и выполнения потока.  

**_В стеке хранятся:_**  
 - **_примитивные типы_** 
 - **_ссылки на объекты в heap_**
 - **_фреймы (frame)_**  

Frame создаётся и кладётся на Stack при вызове метода.  
Frame уничтожается, когда завершается его вызов метода, как в случае нормального завершения, так и в результате выброса неперехваченного исключения.  
**_У каждого потока есть свой Stack и он имеет ограниченный размер._**

Всякий раз, когда мы вызываем новый метод, поверх стека создается новый блок (frame),   
который содержит значения, специфичные для этого метода, например примитивные переменные и ссылки на объекты в heap.
Когда метод завершает выполнение, соответствующий ему frame стека очищается,  
поток возвращается к вызывающему методу, и место становится доступным для следующего метода.  

_Благодаря Escape Analysis и скаляризации из Java 6,объекты,   
которые являются исключительно локальными и не возвращаются за пределы выполняемого метода,  
также сохраняются в стеке._


**_Особенности стековой памяти:_**  
 - **_Stack увеличивается и уменьшается по мере вызова и возврата новых методов соответственно._**
 - **_Переменные внутри Stack существуют только до тех пор, пока работает метод, создавший их._**
 - **_Stack автоматически выделяется и освобождается, когда метод завершает выполнение._**
 - **_Если память Stack заполнена, Java выбрасывает java.lang.StackOverFlowError._**
 - **_Доступ Stack памяти происходит быстрее по сравнению с кучей._**
 - **_Stack память является потокобезопасной, поскольку каждый поток работает в своем собственном Stack._**


### **_Heap_**

**_Heap_** - используется для динамического распределения памяти для объектов Java и классов JRE во время выполнения.  
**_Новые объекты всегда создаются в Heap, а ссылки на эти объекты сохраняются в памяти стека._**  
Эти объекты имеют глобальный доступ, и мы можем получить к ним доступ из любой точки приложения.  

**_Heap делится на два поколения:_**

![HEAP](/images/heap_structure.png)

1. **_Young Generation (Молодое поколение)_**
    - Eden (Эдем)
    - Survivor 0 и Survivor 1 (Выжившие)

2. **_Old Generation (Старое поколение)_**
    - Tenured (Постоянные объекты)


Young разделен на три части: Eden, Survivor 0 и Survivor 1.   
В Eden создаются все новые объекты.   
Один из Survivor регионов всегда пустой.   
При полном заполнении региона Eden запускается малая сборка мусора, и все живые объекты из Eden и Survivor перемещаются в пустой Survivor, а Eden и использующийся Survivor полностью очищается.   
Это делается для уменьшения фрагментации памяти.   
Объекты, которые несколько раз перемещаются между Survivor, затем помещаются в Tenured.

В случае, когда места для новых объектов не хватает уже в Tenured, в дело вступает полная сборка мусора, работающая с объектами из обоих поколений. 
При этом старшее поколение не делится на подрегионы по аналогии с младшим, а представляет собой один большой кусок памяти. 
Поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение, то есть размещение последовательно, без фрагментации. 
Такой механизм очистки называется Mark-Sweep-Compact по названию его шагов (пометить выжившие объекты, очистить память от мертвых объектов, уплотнить выжившие объекты).

Бывают еще объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно.   
В этом случае они размещаются сразу в Tenured.

Младшее поколение занимает одну треть всей кучи, а старшее, соответственно, две трети.   
При этом каждый регион Survivor занимает одну десятую младшего поколения, то есть Eden занимает восемь десятых.

