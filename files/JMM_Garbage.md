### Полезные ссылки

[# Habr - Управление памятью Java](https://habr.com/ru/amp/publications/549176/)  
[# Habr - Избавляемся от мусора в Java](https://habr.com/ru/companies/otus/articles/553996/)  
[# Stack Memory and Heap Space](https://www.baeldung.com/java-stack-heap)  
[# What Is the Maximum Depth of the Java Call Stack?](https://www.baeldung.com/java-call-stack -max-depth)  
[# JVM Garbage Collectors](https://www.baeldung.com/jvm-garbage-collectors)  
[# Habr - Escape analysis и скаляризация: Пусть GC отдохнет](https://habr.com/ru/companies/jugru/articles/322348/)  
[# Откуда растут ноги у Java Memory Model](https://habr.com/ru/articles/440590/)  

## Структура памяти в JAVA


![[images/stackAndHeap.jpeg]]
![[images/java_heap_stack_diagram.png]] 

#### **_Память в Java делится на Stack и Heap._**

### **_Stack_**

**_Stack_** — это область памяти, доступ к которой организован в порядке LIFO.  
Стековая память в Java используется для распределения статической памяти и выполнения потока.  

**_В стеке хранятся:_**  
 - **_примитивные типы_** 
 - **_ссылки на объекты в heap_**
 - **_фреймы (frame)_**  

Frame создаётся и кладётся на Stack при вызове метода.  
Frame уничтожается, когда завершается его вызов метода, как в случае нормального завершения, так и в результате выброса не перехваченного исключения.  
**_У каждого потока есть свой Stack и он имеет ограниченный размер._**

Всякий раз, когда мы вызываем новый метод, поверх стека создается новый блок (frame),  
который содержит значения, специфичные для этого метода, например примитивные переменные и ссылки на объекты в heap.
Когда метод завершает выполнение, соответствующий ему frame стека очищается,  
поток возвращается к вызывающему методу, и место становится доступным для следующего метода.  

_Благодаря Escape Analysis и скаляризации из Java 6,объекты,  
которые являются исключительно локальными и не возвращаются за пределы выполняемого метода,  
также сохраняются в стеке._


**_Особенности Stack:_**  
 - **_Stack увеличивается и уменьшается по мере вызова и возврата новых методов соответственно._**
 - **_Переменные внутри Stack существуют только до тех пор, пока работает метод, создавший их._**
 - **_Stack автоматически выделяется и освобождается, когда метод завершает выполнение._**
 - **_Если память Stack заполнена, Java выбрасывает java.lang.StackOverFlowError._**
 - **_Доступ Stack памяти происходит быстрее по сравнению с кучей._**
 - **_Stack память является потокобезопасной, поскольку каждый поток работает в своем собственном Stack._**


### **_Heap_**

**_Heap_** - используется для динамического распределения памяти для объектов Java и классов JRE во время выполнения.  
**_Новые объекты всегда создаются в Heap, а ссылки на эти объекты сохраняются в памяти стека._**  
Эти объекты имеют глобальный доступ, и мы можем получить к ним доступ из любой точки приложения.  

**_Heap делится на два поколения:_**

![HEAP](/images/heap_structure.png)

1. **_Young Generation (Молодое поколение)_**
    - Eden (Эдем)
    - Survivor 0 и Survivor 1 (Выжившие)

2. **_Old Generation (Старое поколение)_**
    - Tenured (Постоянные объекты)
    - Permanent Generation (Постоянные объекты)

Young разделен на три части: Eden, Survivor 0 и Survivor 1.   
В Eden создаются все новые объекты.   
Один из Survivor регионов всегда пустой.   
**_При полном заполнении региона Eden запускается малая сборка мусора_**, и все живые объекты из Eden и Survivor перемещаются в пустой Survivor, а Eden и использующийся Survivor полностью очищается.   
Это делается для уменьшения фрагментации памяти.   
**_Объекты, которые несколько раз перемещаются между Survivor, затем помещаются в Tenured._**

**_В случае, когда места для новых объектов не хватает уже в Tenured, в дело вступает полная сборка мусора_**, работающая с объектами из обоих поколений. 
При этом старшее поколение не делится на подрегионы по аналогии с младшим, а представляет собой один большой кусок памяти. 
Поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение (Permanent Generation),  
то есть размещение последовательно, без фрагментации.   
Такой механизм очистки называется Mark-Sweep-Compact по названию его шагов (пометить выжившие объекты, очистить память от мертвых объектов, уплотнить выжившие объекты).

Бывают еще объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно.   
В этом случае они размещаются сразу в Tenured.

**_Младшее поколение занимает одну треть всей кучи, а старшее, соответственно, две трети._**   
При этом каждый регион Survivor занимает одну десятую младшего поколения, то есть Eden занимает восемь десятых.

**_Особенности Heap:_**  

- **_Доступ к нему осуществляется с помощью сложных методов управления памятью, 
которые включают Young Generation, Old Generation Tenured и Permanent._**
- **_Если пространство Heap заполнено, Java выдает java.lang.OutOfMemoryError._**
- **_Доступ к Heap сравнительно медленнее, чем к Stack памяти._**
- **_Heap, в отличие от Stack, не освобождается автоматически.   
Для освобождения неиспользуемых объектов и сохранения эффективности использования памяти требуется сборщик мусора._**
- **_В отличие от Stack, Heap не является потокобезопасной и ее необходимо защищать путем правильной синхронизации кода._**

### Где хранятся примитивные поля в классах, в Stack или в Heap?  

```java
class User {
   private int age;
   private String name;

   public void check(int id) {
      int methodPrimitive = 1;
      User user = new User();
   }
}
```
В приведенном примере:
- **_age_** - поле класса, оно имеет примитивный тип и будет храниться там же, где и объект (экземпляр класса), т.е. в Heap.
- **_name_** - поле класса, оно имеет ссылочный тип и будет храниться в Heap.
- **_methodPrimitive_** - поле метода, оно имеет примитивный тип и будет храниться в Stack.
- **_user_** - поле метода, оно имеет ссылочный тип и будет храниться в Stack, сам объект User будет храниться в Heap.



## **_Сборка мусора_**

**_Сборка мусора(Garbage Collection)_** - отслеживает каждый объект, доступный в пространстве Heap JVM, и удаляет неиспользуемые.  
**_Мусором считается объект на который нет 'живых' ссылок._**

По сути, GC работает в два простых шага, известных как Mark and Sweep:

- **_Mark (Пометка)_** —  На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .
- **_Sweep (Очистка)_** — На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
- **_Compact (уплотнение)_** - Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

**_Что такое Stop the World?_**  
Когда запускается этап mark, работа приложения останавливается. После завершения mark приложение возобновляет свою работу. Любая сборка мусора — это "Stop the World".
**_Независимо от реализации Garbage Collector, Stop the World - присутствует всегда._**  

**_Реализации Garbage Collector_**

##### Serial Garbage Collector  
**_Stop the World: есть_**

Это самая простая реализация сборщика мусора, так как она в основном работает с одним потоком. В результате эта реализация сборщика мусора замораживает все потоки приложения при запуске. Поэтому не рекомендуется использовать его в многопоточных приложениях, таких как серверные среды.


##### Parallel Garbage Collector  
**_Stop the World: есть_**

Это сборщик мусора по умолчанию для JVM, который иногда называют сборщиками пропускной способности. В отличие от Serial Garbage Collector, он использует несколько потоков для управления пространством кучи, но также приостанавливает другие потоки приложения во время выполнения GC.

##### CMS Garbage Collector  
**_Stop the World: есть, короткие паузы_**

Реализация Concurrent Mark Sweep (CMS) использует несколько потоков сборщика мусора для сборки мусора. Он разработан для приложений, которые предпочитают более короткие паузы для сборки мусора и могут позволить себе совместно использовать ресурсы процессора со сборщиком мусора во время работы приложения.
Проще говоря, приложения, использующие этот тип сборщика мусора, в среднем отвечают медленнее, но не перестают отвечать для выполнения сборки мусора.
Начиная с JAVA 9 этот сборщик мусора помечен как устаревший.


##### G1 Garbage Collector  
**_Stop the World: очень короткая пауза_**

Сборщик мусора G1 (Garbage First) предназначен для приложений, работающих на многопроцессорных машинах с большим объемом памяти. Он доступен в JDK7 Update 4 и в более поздних версиях.
Сборщик G1 заменит сборщик CMS, так как он более эффективен.
В отличие от других сборщиков, сборщик G1 разбивает кучу на набор областей кучи одинакового размера, каждая из которых представляет собой непрерывный диапазон виртуальной памяти. При сборке мусора G1 показывает параллельную глобальную фазу маркировки (т. е. фазу 1, известную как маркировка), чтобы определить живучесть объектов во всей куче.
После завершения фазы маркировки G1 знает, какие регионы в основном пусты. Сначала он собирается в этих областях, что обычно дает значительное количество свободного места (т.e. Фаза 2, известная как «Sweep»). Вот почему этот метод сборки мусора называется Garbage-First.


##### Z Garbage Collector  
**_Stop the World: очень короткая пауза_**

ZGC (Z Garbage Collector) — это масштабируемый сборщик мусора с малой задержкой, дебютировавший в Java 11 в качестве экспериментального варианта для Linux. JDK 14 представил ZGC для операционных систем Windows и macOS. ZGC получил производственный статус, начиная с Java 15.
ZGC выполняет всю дорогостоящую работу одновременно, **_не останавливая выполнение потоков приложения_** более чем на 10 мс, что делает его подходящим для приложений, требующих низкой задержки. Он использует барьеры нагрузки с цветными указателями для выполнения параллельных операций во время работы потоков, и они используются для отслеживания использования кучи.
Эталонная раскраска (цветные указатели) является основной концепцией ZGC. Это означает, что ZGC использует некоторые биты (биты метаданных) ссылки для обозначения состояния объекта. Он также обрабатывает кучи размером от 8 МБ до 16 ТБ. Кроме того, время паузы не увеличивается с размером кучи, живого набора или корневого набора.
Подобно G1, сборщик мусора Z разделяет кучу, за исключением того, что области кучи могут иметь разные размеры.
