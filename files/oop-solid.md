### Полезные ссылки

[ООП в картинках](https://habr.com/ru/articles/463125/)

## ООП 1

**_Инкапсуляция_** - состояние объекта должен менять сам объект, через свои методы (уровень классов, модулей и тд)

**_Наследование_** - дает возможность порожадать классы насдедники с сохраненем всех свойств и методов суперкласса

**_Полиморфизм_** - поли - много форм - форма, способность организмов существовать в состояниях с различной внутренней структурой или в разных внешних формах во время своего жизненного цикла
- Классы потомки могут изменять поведение класса предка сохраняя его сигнатуру (таким образом сохраняя интрефейс класса предка)
- позволяет обрабатывать объекты классов потомков как однотипные объекты, не смотря на разную реализацию методов

## ООП 2

**_Ассоциация_**

Традиционно в полях объекта могут храниться не только обычные переменные стандартных типов, но и другие объекты.   
А эти объекты могут в свою очередь хранить какие-то другие объекты и так далее, образуя дерево (иногда граф) объектов.   
Это отношение называется ассоциацией.

**_Ассоциация бывает двух видов:_**

1. **_Композиция_** — случай, когда на фабрике трансформеров, собирая Оптимуса, обе пушки ему намертво приколачивают к рукам гвоздями,   
и после смерти Оптимуса, пушки умирают вместе с ним.   
**_Другими словами, жизненный цикл дочернего объекта совпадает с жизненным циклом родительского._**

2. **_Агрегация_** — случай, когда пушка выдается как пистолет в руку, и после смерти Оптимуса этот пистолет может подобрать его боевой товарищ Олег, 
а затем взять в свою руку, либо сдать в ломбард.   
То бишь **_жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, и может использоваться другими объектами._**

## **_Наследование_**

Наследование — это механизм системы, который позволяет, как бы парадоксально это не звучало, наследовать одними классами свойства и поведение других классов для дальнейшего расширения или модификации.

Что если, мы не хотим штамповать одинаковых трансформеров, а хотим сделать общий каркас, но с разным обвесом? ООП позволяет нам такую шалость путем разделения логики на сходства и различия с последующим выносом сходств в родительский класс, а различий в классы-потомки. Как это выглядит?

Оптимус Прайм и Мегатрон — оба трансформеры, но один является автоботом, а второй десептиконом. Допустим, что различия между автоботами и десептиконами будут заключаться только в том, что автоботы трансформируются в автомобили, а десептиконы — в авиацию. Все остальные свойства и поведение не будут иметь никакой разницы. В таком случае можно спроектировать систему наследования так: **_общие черты (бег, стрельба) будут описаны в базовом классе «Трансформер», а различия (трансформация) в двух дочерних классах_** «Автобот» и «Десептикон».

**_Перегрузка/Переопределение_**

Если же в классе-потомке переопределить уже существующий метод в классе-родителе, то сработает **_перегрузка/переопределение_**.   
Это позволяет не дополнять поведение родительского класса, а модифицировать.   
В момент вызова метода или обращения к полю объекта, поиск атрибута происходит от потомка к самому корню — родителю.   
То есть, если у автобота вызвать метод fire(), сначала поиск метода производится в классе-потомке — Autobot, а поскольку его там нет,   
поиск поднимается на ступень выше — в класс Transformer, где и будет обнаружен и вызван.   
**_Следует отметить, что модификация нарушает LSP из набора принципов SOLID, но мы рассматриваем только техническую возможность._**

Как при описании отношений двух сущностей определить, когда уместно наследование, а когда — композиция? 
Можно воспользоваться популярной шпаргалкой: спросите себя, **_сущность А является сущностью Б? Если да, то скорее всего, тут подойдет наследование. 
Если же сущность А является частью сущности Б, то наш выбор — композиция._**

**_Абстрактные классы_**

Кроме обычных классов в некоторых языках существуют абстрактные классы.   
От обычных классов они отличаются тем, что **_нельзя создать объект такого класса._**   
Зачем же нужен такой класс, спросит читатель?   
**_Он нужен для того, чтобы от него могли наследоваться потомки — обычные классы, объекты которых уже можно создавать._**

Абстрактный класс наряду с обычными методами **_содержит в себе абстрактные методы без имплементации_** (с сигнатурой, но без кода),   
которые обязан имплементировать программист, задумавший создать класс-потомок.  
**_Абстрактные классы не обязательны, но они помогают установить контракт, обязующий имплементировать определенный набор методов_**, дабы уберечь программиста с плохой памятью от ошибки имплементации.

## **_Полиморфизм_**

Полиморфизм — свойство системы, позволяющее иметь множество реализаций одного интерфейса.
- Классы потомки могут изменять поведение класса предка сохраняя его сигнатуру (таким образом сохраняя интрефейс класса предка)
- Позволяет обрабатывать объекты классов потомков как однотипные объекты, не смотря на разную реализацию методов

## **_Инкапсуляция_**

**_Инкапсуляция_** — это контроль доступа к полям и методам объекта.  
Под контролем доступа подразумевается не только можно/неможно, но и различные валидации, подгрузки, вычисления и прочее динамическое поведение.  

**_Инкапсуляция_** - состояние объекта должен менять сам объект, через свои методы (уровень классов, модулей и тд) 

## **_Абстракция_**

Абстракция — один из принципов ООП в программировании.   
По своей сути это процесс выделения общих характеристик и функциональности объектов или системы, игнорируя детали реализации.


## SOLID

[Принципы S.O.L.I.D в картинках](https://badtry.net/printsypy-s-o-l-i-d-v-kartinkakh/)  
[SOLID Army](https://pikabu.ru/story/solid_army_7082439)

### **_Single Responsibility Principle / Принцип единственной ответственности_**   
Одна функция должна выполнять только одно законченное действие.  
Этот принцип справедлив и для классов:   
Один класс должен отвечать за какую-то одну задачу.

**_Цель_**  
Этот принцип направлен на разделение поведения таким образом, чтобы в случае возникновения ошибок в результате ваших изменений, это не повлияло на другие, не связанные с этим обязанности.

### **_Open–closed principle. Принцип открытости/закрытости_**

«Классы должны быть открыты для расширения, но закрыты для модификации».

Изменение текущего поведения класса повлияет на все системы, использующие этот класс.  
Если вы хотите, чтобы Класс выполнял больше функций,   
то идеальным подходом является добавление нового функционала к уже существующим функциям **_НЕ_** изменять существующие.

**_Цель_**  
Этот принцип направлен на расширение поведения Класса без изменения существующего поведения этого Класса. Это сделано для того, чтобы избежать возникновения ошибок везде, где используется данный класс.

### **_Liskov substitution principle. Принцип подстановки Барбары Лисков_**

Если S является подтипом T, то объекты типа T в программе могут быть заменены объектами типа S без изменения каких-либо дополнительных свойств этой программы.  
Если дочерний класс S не соответствует этим требованиям, это означает, что дочерний класс S полностью изменяется и нарушает этот принцип.

**_Цель_**  
Этот принцип направлен на обеспечение последовательности, чтобы родительский класс или его дочерний класс могли использоваться одинаковым образом,   
и были взаимозаменяемы, без каких-либо ошибок.

###  **_Interface segregation principle. Принцип разделения интерфейсов._**
Призывает не создавать жирные универсальные интерфейсы. Вместо этого интерфейсы нужно разделять на более мелкие и специализированные, это поможет гибче их комбинировать в имплементирующих классах, не заставляя имплементировать лишние методы.

**_Цель_**  
Этот принцип направлен на разделение набора действий на более мелкие наборы таким образом, чтобы класс выполнял **_ТОЛЬКО_** тот набор действий, который ему нужен.


###  **_Dependency inversion principle. Принцип инверсии зависимостей._**

- Высокоуровневые модули не должны зависеть от более низкоуровневых модулей. Оба должны зависеть от абстракции.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.


Во-первых, давайте определим термины, используемые здесь, проще.  
Высокроуровневый Модуль(или класс): Класс, выполняющий действие с помощью инструмента.  
Низкоуровневый модуль (или класс): Инструмент, необходимый для выполнения действия.  
Абстракция: Представляет собой интерфейс, соединяющий два класса.  
Детали: То, как работает инструмент.  

Этот принцип гласит, что класс не должен смешиваться с инструментом, который он использует для выполнения действия.   
Скорее, он должен быть объединен с интерфейсом, который позволит инструменту соединиться с классом.  
Он также говорит, что и класс, и интерфейс не должны знать, как работает инструмент. 
Однако, инструмент должен соответствовать спецификации интерфейса.  

**_Цель_**  
Этот принцип направлен на уменьшение зависимости высокоуровневого класса от низкоуровневого путем внедрения интерфейса.  

### Что является нарушением принципов SOLID?
* **_Принцип единственной ответственности_** - создание классов, которые отвечают сразу за несколько функций. God object/
* **_Принцип открытости/закрытости_** - изменение существующих методов класса?
* **_Принцип подстановки Барбары Лисков_** - переопределение методов классов наследников, для которых этого не предполагается,
таким образом переопределенный метод будет работать по другому.
* **_Принцип разделения интерфейсов_** - создание интерфейсов отвечающих более чем за одну функцию.
Например, в интерфейс отвечающий за работу с БД, добавить бизнес логику.
* **_Принцип инверсии зависимостей_** - сделать все ровно наборот, точу что указано в описании.