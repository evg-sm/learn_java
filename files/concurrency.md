### Полезные ссылки

[Oracle - concurrency](https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html)  

[!!!Javarush - Ответы на вопросы к собеседованию](https://javarush.com/groups/posts/1611-otvetih-na-voprosih-k-sobesedovaniju-level27)    
[Javarush - Взаимная блокировка (deadlock) в Java и методы борьбы с ней](https://javarush.com/groups/posts/1422-vzaimnaja-blokirovkadeadlock-v-java-i-metodih-borjhbih-s-ney)  
[Синхронизация потоков](http://www.skipy.ru/technics/synchronization.html)  
[Habr - Глубокое погружение в Java Memory Model](https://habr.com/ru/articles/685518/)    
[What Is a Monitor in Computer Science?](https://www.baeldung.com/cs/monitor)  
[Javarush - Многопоточность в Java: суть, «плюсы» и частые ловушки](https://javarush.com/groups/posts/1992-mnogopotochnostjh-v-java-sutjh-pljusih-i-chastihe-lovushki-)    
[Habr - Введение в многопоточность в Java очень простым языком: Процессы, Потоки и Основы синхронизации](https://habr.com/ru/articles/745910/)    
[Javarush - Управление потоками. Ключевое слово volatile и метод yield()](https://javarush.com/groups/posts/1998-upravlenie-potokami-metodih-volatile-i-yield)  
[Habr - Многопоточность в Java. Работа с потоками](https://habr.com/ru/sandbox/167189/)  
[Baeldung - Guide to the Volatile Keyword in Java](https://www.baeldung.com/java-volatile)  
[Baeldung - wait and notify() Methods in Java](https://www.baeldung.com/java-wait-notify)  
[Baeldung - A Guide to the Java ExecutorService](https://www.baeldung.com/java-executor-service-tutorial)  
[Baeldung - Introduction to Thread Pools in Java](https://www.baeldung.com/thread-pool-java-and-guava)  
[Baeldung - An Introduction to Atomic Variables in Java](https://www.baeldung.com/java-atomic-variables)  
[Baeldung - An Introduction to ThreadLocal in Java](https://www.baeldung.com/java-threadlocal)  

#todo Секреты Concurrency: от процессора до атомиков в Go | Полное руководство
https://vkvideo.ru/video-230033131_456239041?t=5m38s
#todo

some new text

### Монитор и синхронизация  

[What Is a Monitor in Computer Science?](https://www.baeldung.com/cs/monitor)  

**_Монитор_** — это механизм синхронизации, который позволяет потокам иметь:

* **_взаимное исключение (mutual exclusion)_** — только один поток может выполнить метод в определенный момент времени, используя блокировки (synchronized)
* **_сотрудничество (cooperation)_** — возможность заставить потоки ждать выполнения определенных условий, используя wait-set (wait / notify)

**_Почему эта функция называется «монитор»? Потому что он отслеживает (мониторит), как потоки обращаются к некоторым ресурсам._**

**_Мониторы предоставляют три основные функции_** для параллельного программирования:

* **_только один поток одновременно имеет взаимоисключающий (эксклюзивный) доступ к критической части кода._**
* **_потоки, работающие в мониторе, могут быть заблокированы, пока они ждут выполнения определенных условий._**
* **_один поток может уведомлять другие потоки, когда выполняются условия, которых они ожидают._**

**_Критическая секция_** — это часть кода, которая обращается к одним и тем же данным через разные потоки.

### Как Java реализует мониторы?
В Java мы используем ключевое слово **_synchronized_** для обозначения критических разделов. Мы можем использовать его для:  
* **_маркировки методов (также называемых синхронизированными методами)_**
* **_или даже небольших частей кода (синхронизированные операторы)._**  

### Методы wait() and notify()  

**_Методы wait() and notify() могут быть использованы только в связке с synchronized._**  

Одним из инструментов, который мы можем использовать для координации действий нескольких потоков в Java, являются защищенные (synchronized) блоки. Такие блоки проверяют определенное условие перед возобновлением выполнения.

* **_Object.wait()_** - для приостановки потока.
* **_Object.notify()_** - для пробуждения потока.
* **_Object.notifyAll()_** - для пробуждения всех потоков.  

### Жизненый цикл потока:  
* **_NEW_** — новый, только что созданный поток. Это состояние присваивается, когда выделяется память для объекта.
Thread myThread = new Thread();
* **_RUNNABLE_** — вызывая метод start(), поток становится готовым к выполнению, а затем выполняемым.
* **_RUNNING_** - выполняемый поток.
* **_BLOCKED / WAITING / TIME_WAITING_** — данные состояния означают, что поток находится в ожидании своего выполнения.
* **_TERMINATED_** — после завершения работы поток уничтожается.  

### Метод notify  
Мы используем метод notify() для пробуждения потоков, ожидающих доступа к монитору этого объекта.  
Существует два способа уведомления ожидающих потоков:  

* **_notify_** - Для всех потоков, ожидающих на мониторе этого объекта, метод notify() уведомляет любой из них о произвольном пробуждении.
Выбор того, какой именно поток разбудить, **_недетерминирован_** (не определен) и зависит от реализации.
Поскольку notify пробуждает один случайный поток, мы можем использовать его для реализации взаимоисключающей блокировки, когда потоки выполняют схожие задачи. 
Но в большинстве случаев было бы целесообразнее реализовать notifyAll.

* **_notifyAll_** - Этот метод просто пробуждает все потоки, ожидающие на мониторе этого объекта.
Пробужденные потоки будут конкурировать обычным образом, как и любой другой поток, пытающийся синхронизироваться на этом объекте.

### Какие проблемы могут возникнуть в многопоточном коде  
В многопоточном коде могут возникнуть две проблемы: **_Взаимная блокировка_** и **_Состояние гонки._**  

**_Взаимная блокировка (Deadlock)_** - это ситуация, когда **_два или более потока зациклено ожидают друг друга_**, 
чтобы освободить ресурсы или завершить определенные операции. 
В результате ни один из потоков не может продолжить свое выполнение, так как каждый из них блокирует ресурсы, 
необходимые для завершения работы другого потока. 
Это приводит к тому, что программа останавливается и не может продолжить свое выполнение, 
пока ситуация deadlock не будет разрешена вручную.

**_Состояние гонки (Race condition)_** - это ситуация, когда **_два или более потока одновременно обращаются к общим данным_** или ресурсам, 
и результаты их операций зависят от того, **_в каком порядке выполняются операции_**. 
Это может привести к непредсказуемым и нежелательным результатам, таким как неправильные значения или ошибки в программе. 
В результате состояния гонки данные или ресурсы могут быть повреждены или использованы неправильно.  

### Как сделать deadlock  
Аналогично, как и на базе данных.

Есть два объекта А и Б.
* В первом потоке - Получить блокировку объека А, затем блокировку объекта Б.
* Во втором потоке - Получить блокировку объека Б, затем блокировку объекта А.
Для воспроизведения можно использовать CyclicBarrier. 
CyclicBarrier - Средство синхронизации, позволяющее всем потокам ожидать друг друга, пока они не достигнут общей точки барьера.

### Красные флаги, все то, что ведет к deadlock:  
* **_Блок synchronized вложен один в другой!_**
* **_Synchronized метод вызывает другой synchronized метод!_**  

### Ключевое слово Volatile  
**_Volatile_** - оптимизация, которая позволяет разным потоком 'видеть' данные, помеченные ключевым словом Volatile.  
* Во-первых, в процессе работы многопоточного приложения разные потоки могут кэшировать значения переменных.
* Во-вторых, в Java операции чтения и записи полей всех типов, кроме long и double, являются атомарными.  

Наличие **_Volatile_**, гарантирует, что:
* Она всегда будет атомарно читаться и записываться. Даже если это 64-битные double или long.
* Java-машина не будет помещать ее в кэш. Так что ситуация, когда 10 потоков работают со своими локальными копиями исключена.  

### Как работают Атомики (Atomic)?  

**_Атомарная операция_** — это операция, которая выполняется полностью или не выполняется совсем, частичное выполнение невозможно.

**_Атомики_** — это классы, которые выполняют операции изменения своего значения атомарно, т.о. 
они поддерживают lock-free thread-safe использование переменных. 
Достигается это с помощью **_алгоритма compare-and-swap (CAS)_** и работает быстрее, 
чем аналогичные реализации с блокировками. 
На уровне инструкций большинства процессоров имеется поддержка CAS.


В общем случае работу Атомиков можно описать следующим образом. 
Атомик хранит некоторое **_volatile_** значение value, для изменения которого используется метод compareAndSet(current, new), 
поэтому предварительно читается текущее значение — current. 
Данный метод с помощью CAS изменяет значение value только в том случае, 
если оно равно ожидаемому значению (т.е. current), прочитанному перед запуском compareAndSet(current, new). 
Если значение value было изменено в другом потоке, то оно не будет равно ожидаемому. 
Следовательно, метод compareAndSet вернет значение false. 
Поэтому следует повторять попытки чтения текущего значения и запуска с ним метода compareAndSet(current, new)пока current не будет равен value.


**_Условно можно разделить методы Атомиков на:_**  
* **_compare-and-set_** — принимают current на вход и делают одну попытку записи через CAS
* **_set-and-get_** — самостоятельно читают current и пытаются изменить значение с помощью CAS в цикле, как описано выше

Непосредственно изменение значения value делегируется либо VarHandle, либо Unsafe, которые в свою очередь выполняют его на нативном уровне. VarHandle — это динамически сильно типизированная ссылка на переменную или на параметрически определяемое семейство переменных, включающее статические поля, нестатические поля, элементы массива или компоненты структуры данных нестандартного типа. Доступ к таким переменным поддерживается в различных режимах, включая простой доступ на чтение/запись, volatile доступ на чтение/запись и доступ на compare-and-swap.  


### Как создать новый Thread (поток)?  
- **_Наследоваться от класса Thread_** и переопределить метод run(), затем выполнить запуск new SomeThread().start();  
- **_Имплементировать интерфейс Runnable_** и передать в конструктор нового потока new Thread(new Runnable() {...}).start()  
- **_Имплементировать интерфейс Callable_** и запустить с помощью Executor или ExecutorService  
- **_Lambda_** - Runnable и Callable можно заменить на Lambda

### Runnable vs Callable vs Future  
- **_Runnable_** - функциональный интерфейс, не принимает аргументов и не возвращает никакого результата.
При использовании **_ExecutorService с возвращаемым типом Future, вернет пустой результат (null)_**.
- **_Callable_** - функциональный интерфейс, не принимает аргументов и не возвращает обобщенный (generic) результат.  
- **_Callable и Runnable_** - инкапсулирует задачу, предназначенную для запуска в другом потоке.  
- **_Future_** используется для хранения результата, полученного из другого потока.

#### Обработка исключений  
- **_Runnable_** - поскольку в сигнатуре метода не указано предложение «throws», у нас нет возможности распространять дальнейшие проверяемые исключения.
- **_Callable_** - содержит предложение «throws exception», поэтому мы можем легко распространять проверяемые исключения дальше.  
При использовании ExecutorService, исключения будут собраны в объекте Future. Чтобы получить исключение надо вызвать метод **_Future.get()_**.
Все исключения будут обернуты в **_ExecutionException_**, чтобы получить оригинальное исключение: надо вызвать метод **_getCause()_**.  

### Executor  
**_void execute(Runnable command)_**;  
интерфейс выполнятора параллельных задач.

### ExecutorService  
Уже покруче, может запускать Callable, Runnable, может возвращать Future.   
**_Есть методы:_**  
- **_invokeAll_** - запустить все таски. 
- **_invokeAny_** - запустить любую таску.
- **_submit_** - запустить отдельную таску.
- **_shutdown_** - останавливает прием новых тасок в обработку.  
- **_shutdownNow_** - пытается немедленно уничтожить ExecutorService, но он не гарантирует, что все запущенные потоки будут остановлены одновременно.  

### Как правильно останавливать ExecutorService  
- По рекомендации Oracle сначала надо вызвать метод shutdown, затем ждем полной остановки и проверям методом
awaitTermination с неким timeout, после чего вызываем shutdownNow.  
- В Springboot server.shutdown=graceful - будет ждать в том числе остановки ExecutorService.  

### Какие есть типы ExecutorService в Executors  
- **_new ThreadPoolExecutor()_** - базовый конструктор, принимает на вход corePoolSize, 
  * corePoolSize - минимальное количество потоков.
  * maximumPoolSize - максимальное количество потоков.
  * keepAliveTime - когда количество потоков больше corePoolSize, время их жизни.
  * workQueue – очередь, которая используется для хранения задач, пока они не выполнены.  
- **_Executors.newSingleThreadExecutor()_** - выполнятор с одним потоком.   
- **_newFixedThreadPool_** - выполнятор с фиксированным пулом потоков, который не меняется со временем.  
- **_newCachedThreadPool_** - выполнятор с динамическим пулом потоков. Используется для большого количества коротко живущих задач.  
- **_newScheduledThreadPool_** - выполнятор с возможность отложить выполнение на определенное время или по расписанию.  


