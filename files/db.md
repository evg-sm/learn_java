
### Полезные ссылки

[Habr - Шпаргалка по SQL (postgres), которая выручает меня на собесах](https://habr.com/ru/articles/745948/)


### Проблема N+1  
Проблема N+1 может возникнуть не только при использовании Hibernate, 
но и других библиотек и фреймворков для доступа к данным.

В общем случае говорят о проблеме N+1 запроса, когда фреймворк выполняет N дополнительных запросов выборки данных, 
когда можно было обойтись всего одним.
Соответственно от размера N зависит влияние проблемы на время ответа нашего приложения. 
Эту ситуацию нельзя обнаружить с помощью slow query log, ибо сами по себе запросы могут выполняться быстро, 
но их количество окажется большим или даже огромным.

На такое можно нарваться даже при использовании **_plain sql_** (jdbc, JOOQ), 
когда у нас одна сущность (и соответственно таблица) связана с другой. 
И вот мы подгрузили одним запросом просто список из первых, 
а потом пошли и в цикле для каждой подгрузили связанную по одному запросу. "Да как вы это допустили!?". 
Да просто по запарке кто-то в цикле начал вызывать метод, у которого в глубине где-то делается запрос и привет. 
Как исправить? **_Использовать JOIN_** со связанной таблицей при чтении списка. Тогда понадобиться лишь один запрос.  


**_Теперь к Hibernate._** 
Стратегия выборки **_FetchType.EAGER склонна к порождению N+1_**.   
А в отношении @ManyToOne по умолчанию используется именно она.   
**_Забыли в своём JPQL запросе использовать JOIN FETCH и привет._**  
А если нам и не нужны были связанные сущности, то тогда стоит задать стратегию FetchType.LAZY. 

**_FetchType.LAZY не гарантирует отсутствие проблемы N+1._**  
При выборке списка сущностей, связанные автоматически не подгрузились.   
А мы потом пошли в цикле по загруженному списку и стали обращаться к полям связанной сущности — и снова здравствуйте.   
Всё тот же **_JOIN FETCH_** нас спасёт и в этой ситуации.

Но JOIN FETCH во многих случаях нас может привести к декартовому произведению, и тогда будет совсем bonjour.   
Для отношения **_@OneToMany_** это можно решить с помощью **_FetchMode.SUBSELECT — будет 2 запроса_**,  
но во втором запросе на получение списка связанных сущностей в условии выборки будет подзапрос на получение идентификаторов родительских сущностей. Т.е. запрос практически повторяется и он может быть тяжеловесным.

**_Есть вариант лучше — вычитывать связанные сущности пачками. Мы можем добавить аннотацию @BatchSize_**  
и указать размер подгружаемой пачки записей в одном запросе.

Ещё варианты:

[JPA EntityGraph](https://www.baeldung.com/jpa-entity-graph)  
[Hibernate FetchProfile](https://docs.jboss.org/hibernate/stable/core/userguide/html_single/Hibernate_User_Guide.html#fetching-strategies-dynamic-fetching-profile-example)  


### Что такое "Нормализация"

Нормализация как раз и подразумевает собой процесс приведения базы данных к нормальным формам с целью избавления от логической избыточности,
а декомпозиция - это одна из вариаций нормализации.
Нормальных форм существует аж 8: с 1NF и до 6NF а также Бойса-Кодда и Доменно-ключевая формы.


### Что такое транзакция? 

Транзакция - это элементарная операция в базе данных.
Логически целостная процедура состоящие из нескольких sql операторов.
В процессе выполнения должны быть выполнены все операторы или не выполнены вовсе.

Транзакция начинается с команды BEGIN и заканчивается командой COMMIT либо отменяется командой ROLLBACK.


### Что такое распределенная транзакция? 

Распределенная транзакция - это та транзакция: которая затрагивает несколько ресурсов.


## Реляционные субд 

https://www.oracle.com/cis/database/what-is-a-relational-database/

Реляционная база данных – это набор данных с предопределенными связями между ними. Эти данные организованны в виде набора таблиц, состоящих из столбцов и строк. В таблицах хранится информация об объектах, представленных в базе данных. В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке – значение атрибута. Каждая стока таблицы представляет собой набор связанных значений, относящихся к одному объекту или сущности. Каждая строка в таблице может быть помечена уникальным идентификатором, называемым первичным ключом, а строки из нескольких таблиц могут быть связаны с помощью внешних ключей. К этим данным можно получить доступ многими способами, и при этом реорганизовывать таблицы БД не требуется.

БД состоит из:

- Таблицы (table)
- Индексы (index)
- правила целостности (constraint)
- primary key (уникальный идентификатор для строк в БД) (unique) (not NULL) по умолчанию
- foreign key (целостность ссылок между двумя таблицами)
- unique
- not NULL
- check
- представления (view)
- процедуры (procedure)
- функции (function)
- тригеры (trigger)

## ACID 

***ACID*** - набор требований к транзакционной системе, обеспечивающий наиболее надёжную и предсказуемую её работу.

Свойства транзакций:

**_A_** - Атомарность

**_C_** - Консистентность

**_I_** - Изоляция

**_D_** - Долговременность

### *Описание 1*

**Atomicity** (атомарность) — выражается в том, что транзакция должна быть выполнена целиком, т.е. выполнены все операторы транзакции или не выполнена вовсе.


**Consistency** (согласованность) — гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое, то есть транзакция не может разрушить взаимной согласованности данных.


**Isolation** (изолированность) — локализация пользовательских процессов означает, что конкурирующие за доступ к БД транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит, как будто они выполняются параллельно.


**Durability** (долговечность) — устойчивость к ошибкам — если транзакция завершена успешно, то те изменения в данных, которые были ею произведены, не могут быть потеряны ни при каких обстоятельствах.

### *Описание 2*

**Атомарность** гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было

**Консистентность**
Транзакция, достигающая своего нормального завершения (англ. end of transaction, EOT) и тем самым фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвёртого свойства.

**Изоляция**
Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность — требование дорогое, поэтому в реальных базах данных существуют режимы, не полностью изолирующие транзакцию (уровни изолированности, допускающие фантомное чтение и ниже).

**Долговременность**
Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.


## Уровни изоляции транзакций 

**_Проблемы параллельного доступа с использованием транзакций:_**

**_Потерянное обновление (lost update)_** - Эффект проявляется при одновременном изменении одного блока данных разными транзакциями. Причём одно из изменений может теряться.

**_Грязное чтение (dirty read)_** - транзакция читает данные, записанные параллельной незавершенной транзакцией. Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе.

**_Неповторяемое чтение (unrepeatable read)_** - транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией.

**_Фантомное чтение (phantom read)_** - транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обраруживает, что набор строк,
удовлетворяющий условию, изменился из-за транзакции, завершившейся за это время.

**_Аномалия сериализации (serialization anomaly)_** - результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди


### Непосредственно уровни изоляции:

![Уровни изоляции 1](/images/transaction_isolation_1.jpg)

![Уровни изоляции 2](/images/transaction_isolation_2.jpg)


### Как уровень изоляции транзакций влияет на производительность? 

Чем выше уровень изоляции транзакций, тем больше накладные расходы в БД


### Как в java изменить уровень изоляции транзакций? 

- В чистом jdbc у класса Connection есть метод setTransactionIsolation
- В аннотации @Transactional(isolation = Isolation.READ_UNCOMMITTED)
- В TransactionManager метод


## Блокировки 

[Habr - Блокировки как один из способов обеспечения изоляции транзакций](https://habr.com/ru/companies/otus/articles/506072/)

Существует два способа управления параллелизмом:
- Повышение уровня изоляции транзакций
- Блокировка данных, которые нам нужны в данный момент

Уровень изоляции транзакций устанавливается для _соедиения_ (connection) базы данных.
Тем самым он влияет на все инстукции в этом соединении.
_**Чем выше уровень изоляции тем больше накладных расходов на БД.**_

Однако есть возможность установливать блокировки непосредственно на данные при использовании JPA.
Существует два типа блокировок:
- Оптимистичные
- Писсимистичные


### Оптимистичные (Optimistic Locking) 

[Baeldung - Optimistic Locking in JPA](https://www.baeldung.com/jpa-optimistic-locking)

**_Оптимистичные блокировки работают на уровне приложения. Блокировок на уровне БД не создается_**

_**Как это работает:**_
Открывается транзакция - фиксируется версия сущности - выполняются операторы транзакции
- если версия сущности НЕ изменилась - транзакция фиксируется + инкрементится версия сущности
- если версия сущности изменилась - получаем OptimisticLockException

Для этого на сущность в БД необходимо установтить аннотацию @Version.
Обычно эта аннотация устанавливается на поле сущности с типом int, Integer, long, Long, short, Short, java.sql.Timestamp
При этом каждая транзакция, которая считывает данные, содержит значение поля версии @Version.
Прежде чем транзакция захочет выполнить обновление, она снова проверяет свойство версии.
Если за это время значение изменилось, создается исключение OptimisticLockException.
В противном случае транзакция фиксирует обновление и увеличивает значение свойства версии.
Оптимистическая блокировка основана на обнаружении изменений в сущностях путем проверки их атрибута версии.
Этот механизм подходит для приложений, которые выполняют гораздо больше операций чтения, чем обновления или удаления.

_**Режимы блокировок:**_

- OPTIMISTIC устанавливает оптимистическую блокировку чтения для всех сущностей, содержащих атрибут версии.
- OPTIMISTIC_FORCE_INCREMENT получает оптимистическую блокировку, такую же, как OPTIMISTIC, и дополнительно увеличивает значение атрибута версии.

_**Как установить оптимистическую блокировку:**_
- Доступна по умолчанию для сущностей с аннотацией @Version
- Query query = entityManager.createQuery() ... query.setLockMode(LockModeType.OPTIMISTIC_INCREMENT)
- entityManager.lock(student, LockModeType.OPTIMISTIC)
- Использовать аннотацию @NamedQuery на сущности


### Писсимистичные (Pessimistic Locking) 

[Baeldung - Pessimistic Locking in JPA](https://www.baeldung.com/jpa-pessimistic-locking)

**_Писсимистичные блокировки работают на уровне базы данных, под капотом это 'SELECT … FOR UPDATE'_**

**_Есть два механизма управления параллелизмом:_**
- Установка надлежащего уровня изоляции транзакций
- Установка блокировки данных, которые нам нужны в данный момент.
  Уровень изоляции транзакций устанавливается на все соединение и соответственно увеличивает накладные расходы на каждую транзакцию.
  В противовес можно использовать 'писсимистичные блокировки', которые обеспечивают более гранулярные блокировки на уровне базы данных.
  Мы можем использовать пессимистическую блокировку, чтобы гарантировать,
  что никакие другие транзакции не смогут изменить или удалить зарезервированные данные.

**_Есть два типа блокировок:_**
- Экслюзивные (exclusive) - позволяет изменять и удалять зарезервированные данные.
- Общие (shared) - можем читать, но не писать данные, когда кто-то еще держит shared блокировку.

_**Получить экслюзивную блокировку можно через 'SELECT … FOR UPDATE'.**_

**_Режимы блокировок:_**
- PESSIMISTIC_READ позволяет нам получить общую блокировку (shared) и предотвратить обновление или удаление данных.
- PESSIMISTIC_WRITE позволяет нам получить эксклюзивную блокировку (exclusive) и предотвратить чтение, обновление или удаление данных.
- PESSIMISTIC_FORCE_INCREMENT работает так же, как PESSIMISTIC_WRITE, и дополнительно увеличивает атрибут версии версионного объекта.

**_Мы можем получить только одну блокировку за раз. Если это невозможно, генерируется PersistenceException._**

### Как установить пессимистическую блокировку блокировку:
- Аналогично как и оптимистическую.

### Области блокировок:
Область определяет блокировать одну сущность или и сущность и все ее связи (вложенные связанные сущности)
Установить можно через - EntityManager, Query, TypedQuery or NamedQuery:

- PessimisticLockScope.NORMAL - блокирует только саму сущность. Также блокирует предков сущноси.
- PessimisticLockScope.EXTENDED - блокирует связанные сущности. При использовании @ElementCollection or @OneToOne, @OneToMany, etc. with @JoinTable.


## Индексы 


**_Полнотекстовый поиск_** — автоматизированный поиск документов, при котором поиск ведётся не по именам документов, а по их содержимому, всему или существенной части.

**_TID_** - tuple identifier, идентификатор строки/кортежа.


### B-tree 

Используется для сравнения:  '<' '>' '='  
Полнотекстовый поиск: -.

Основан на сбалансированном дереве.  
Кореневая страница содержит диапозоны которые ссылкаются на промежуточные страницы, которые тоже содежат диаопозоны и они ссылаются на листья.  
Листья содержан непосредственно TID-ы.


### HASH 

Используется для сравнения: '='  
Полнотекстовый поиск: -

Очень быстро работает на прямое сравнение.  
Куда быстрее всех других индексов.
Работает аналогично hashMap.  
Хранит ключ-значени: key: значение хеш функции value: TID (ссылка на строку в таблице)


### GiST 

Используется для: точки геолокации, полнотекстовый поиск  
Полнотекстовый поиск: + (долгий на чтение, быстрый на запись)

Generalized Search Tree - Обобщенное поисковое дерево.
Это тоже сбалансированное дерево и в нем в каждом узле мы определяем некий предикат или условие, которое должно выполняться для всех узлов ниже.

Полнотекстовый поиск - в корне содержит все предикаты, в промежуточных страницах хранит части предикатов, которые ссылаются на листья с TID'ами.
В реальности используется сигнатурное дерево, где символам соответствует набор битов. Т.е. под капотом это битово дерево.
Возможно возникновение коллизий, когда разным наборам символов соответсвует один набор битов. Чревато двойным чтением.


### SP-GiSt 

Используется для: точки геолокации  
Полнотекстовый поиск: -

Не сбалансированное дерево, SP - spacepatiotioned означает разделение пространства. Пространство - друмерная плоскость.
Используется только для индексации точек(на карте). Идея состоит в том, чтобы рекурсивно разделить области на четыре части(квадранта)
относительно центральной точки. Области не пересекаются

### GIN 

Используется для: полнотекстовый поиск  
Полнотекстовый поиск: + (лучший для поиска по jsonb) (быстрое чтение, медленная запись)

Generalized Inverted Index - так называемый обратный индекс, хорошо подходит для полнотекстового поиска.
Харнит все строки содержащие то или иное слово поиска
Фактически хранит map: key: слово value: список TID
Быстро работает на чтение и медленно на записть,
т.к. для добавлении строки надо проийтись по всем значениям и добавить новое, при необходимости.


### BRIN 
Индекс блоковых зон. Block Range Index.
Используется для больших и отсортированных таблиц.
Основная идея в том чтобы отбросить ненужные страницы.
Не будет ошибкой рассматривать BRIN не как индекс в обычном понимании, а как ускоритель последовательного сканирования таблицы.

[Habr - Индексы в PostgreSQL — 9](https://habr.com/ru/companies/postgrespro/articles/346460/)


### Составные индексы 

Это индексы на два и более полей в таблице.
Составными могут быть только индексы: B-tree, GiST, GIN и BRIN.
Т.е. все кроме hash индексов.

Составные индексы следует использовать обдуманно.  
В большинстве случаев индекс по одному столбцу будет работать достаточно хорошо и сэкономит время и место.  
Индексы по более чем трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно.


### Функциональные индексы 

Или индексы по выражениям.

**_Пример:_**  
`SELECT * FROM test1 WHERE lower(col1) = 'value';`  
**_Индекс:**_  
`CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));`



### Как построить индекс без блокировки таблицы? 

Ключевое слово 'CONCURRENTLY ' CREATE INDEX CONCURRENTLY



### Блокировки в PostgreSQL
https://www.youtube.com/watch?v=TCEvRlvi-fM  
https://www.cybertec-postgresql.com/en/postgresql-understanding-deadlocks/



### Как сделать deadlock? 
[How does a deadlock happen?](https://www.cybertec-postgresql.com/en/postgresql-understanding-deadlocks/)

1. Две паралельные транзакции одновляют две таблицы в разной последовательности.

Например, если транзакция 1 получает исключительную блокировку таблицы A, а затем пытается получить исключительную блокировку таблицы B, которую до этого получила транзакция 2, в данный момент требующая исключительную блокировку таблицы A, ни одна из транзакций не сможет продолжить работу.

BEGIN;  
select * from bot.tst_1 for update ;  
select pg_sleep(10);  
select * from bot.tst_2 for update ;  
COMMIT;  

BEGIN;  
select * from bot.tst_2 for update ;  
select pg_sleep(10);  
select * from bot.tst_1 for update ;  
COMMIT;  

2. Две паралельные транзакции обновляют одну строку! Пока не воспроизвел.

### Как избежать  deadlock?
**_Выполять операторы sql последовательно, или не в рамках одной транзакции, или в обоих транзакциях в одном порядке._**



### Как работает @transactional? 

https://habr.com/ru/articles/532000/  
https://docs.spring.io/spring-framework/docs/4.1.5.RELEASE/spring-framework-reference/html/transaction.html  
https://www.baeldung.com/spring-transactional-propagation-isolation  

Под капотом работает так же как и раньше

Connection connection = DriverManager.getConnection(...)



### Свойства транзакции spring? @Transactional #

[Baeldung -Transaction Propagation and Isolation in Spring @Transactional](https://www.baeldung.com/spring-transactional-propagation-isolation)

- transactionManager

- _propagation_ - распространение - default Propagation.REQUIRED
    * REQUIRED - создание новой транзакции, если ее нет.
    * SUPPORTS - выполнять в текущей транзакции, выполнять без транзакции, если ее не существует.
    * MANDATORY - выполнять в текущей транзакции, выбросить исключение, если ее не существует
    * REQUIRES_NEW - создать новую транзакцию и приостановить текущую транзакцию, если она существует.
    * NOT_SUPPORTED - выполнить без транзакции, приостановить текущую транзакцию, если она существует.
    * NEVER - выполнить без транзакций, выбросить исключение, если транзакция существует.
    * NESTED - выполнить во вложенной транзакции, если текущая транзакция существует, в противном случае вести себя как REQUIRED
- _Isolation_ - описано выше
- _readOnly_ - флаг, для которого можно установить значение true, если транзакция фактически доступна только для чтения, что позволяет проводить соответствующую оптимизацию во время выполнения.
- _rollbackFor_ - Определяет ноль (0) или более классов исключений, которые должны быть подклассами Throwable, указывая, какие типы исключений должны вызывать откат транзакции.
- _rollbackForClassName_ - аналогично по имени класса.
- _noRollbackFor_ - противоположные по значение атрибуты. Какие исключения не должны вызывать откат транзакции.
- _noRollbackForClassName_ - ***

### Порядок полей в индексе и в запросе  
**_Есть индекс по 3-м полям (1, 2, 3)_**
- Запрос по полям (1, 2, 3) **_будет_** использовать индекс.
- Запрос по полям (1, 2) **_будет_** использовать индекс.
- Запрос по полям (1) **_будет_** использовать индекс.
- Запрос по полям (2, 3) **_НЕ будет_** использовать индекс.
- Запрос по полям (3) **_НЕ будет_** использовать индекс.

**_Есть индекс по 1-му полю (1)_**
- Запрос по полям (1) **_будет_** использовать индекс.
- Запрос по полям (1, 2) **_будет_** использовать индекс.
- Запрос по полям (1, 2, 3) **_будет_** использовать индекс.

### Преимущества и недостатки индексов  
- Индекс ускоряет 'чтение'.
- Индекс замедляет 'запись', т.к каждый раз при записи обновляется индекс.
- индекс занимает большой объем памяти в БД.


### Чем отличается PreparedStatement от Statement 

**_Интерфейс Statement_** - Выполняет простой оператор SQL без параметров.  
**_Интерфейс PreparedStatement_** - Выполняет подготовленный оператор SQL с входными параметрами или без них.  
Может кешироваться на уровне БД.  
**_Интерфейс CallableStatement_** - предназначен для вызова хранимых процедур SQL.  



### Миграция данных  
- Миграцию по инкрементальным id можно организовать непосредственно по самим id,
т.е. отбирать их батчами по id.
- Миграцию по UUID можно организовать следующими способами:
  * Сделать дополнительное VIEW, где сопоставить инкрементальный id с UUID (плохой вариант).
  * Сделать дополнительное VIEW или таблицу, где можно добавить новый столбец, который будет отвечать за статус миграции
конкретной строки, например, migrated = true (хороший вариант).