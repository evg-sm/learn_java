#### Полезные ссылки

https://habr.com/ru/articles/745948/

### Что такое "Нормализация"

Нормализация как раз и подразумевает собой процесс приведения базы данных к нормальным формам с целью избавления от логической избыточности,
а декомпозиция - это одна из вариаций нормализации.
Нормальных форм существует аж 8: с 1NF и до 6NF а также Бойса-Кодда и Доменно-ключевая формы.


### Что такое транзакция? 

Транзакция - это элементарная операция в базе данных.
Логически целостная процедура состоящие из нескольких sql операторов.
В процессе выполнения должны быть выполнены все операторы или не выполнены вовсе.

Транзакция начинается с команды BEGIN и заканчивается командой COMMIT либо отменяется командой ROLLBACK.


### Что такое распределенная транзакция? 

Распределенная транзакция - это та транзакция: которая затрагивает несколько ресурсов.


### Реляционные субд 

https://www.oracle.com/cis/database/what-is-a-relational-database/

Реляционная база данных – это набор данных с предопределенными связями между ними. Эти данные организованны в виде набора таблиц, состоящих из столбцов и строк. В таблицах хранится информация об объектах, представленных в базе данных. В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке – значение атрибута. Каждая стока таблицы представляет собой набор связанных значений, относящихся к одному объекту или сущности. Каждая строка в таблице может быть помечена уникальным идентификатором, называемым первичным ключом, а строки из нескольких таблиц могут быть связаны с помощью внешних ключей. К этим данным можно получить доступ многими способами, и при этом реорганизовывать таблицы БД не требуется.

БД состоит из:

###### Таблицы (table)
###### Индексы (index)
###### правила целостности (constraint)
###### primary key (уникальный идентификатор для строк в БД) (unique) (not NULL) по умолчанию
###### foreign key (целостность ссылок между двумя таблицами)
###### unique
###### not NULL
###### check
###### представления (view)
###### процедуры (procedure)
###### функции (function)
###### тригеры (trigger)

### ACID 

ACID - набор требований к транзакционной системе, обеспечивающий наиболее надёжную и предсказуемую её работу.

Свойства транзакций:

**A** - Атомарность

**C** - Консистентность

**I** - Изоляция

**D** - Долговременность

**Atomicity** (атомарность) — выражается в том, что транзакция должна быть выполнена целиком, т.е. выполнены все операторы транзакции или не выполнена вовсе.


**Consistency** (согласованность) — гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое, то есть транзакция не может разрушить взаимной согласованности данных.


**Isolation** (изолированность) — локализация пользовательских процессов означает, что конкурирующие за доступ к БД транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит, как будто они выполняются параллельно.


**Durability** (долговечность) — устойчивость к ошибкам — если транзакция завершена успешно, то те изменения в данных, которые были ею произведены, не могут быть потеряны ни при каких обстоятельствах.


‌ Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было

‌ Консистентность
Транзакция, достигающая своего нормального завершения (англ. end of transaction, EOT) и тем самым фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвёртого свойства.

‌ Изоляция
Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность — требование дорогое, поэтому в реальных базах данных существуют режимы, не полностью изолирующие транзакцию (уровни изолированности, допускающие фантомное чтение и ниже).

‌ Долговременность
Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

#####
#####

 Уровни изоляции транзакций 

Проблемы параллельного доступа с использованием транзакций:

‌ Потерянное обновление (lost update) - Эффект проявляется при одновременном изменении одного блока данных разными транзакциями. Причём одно из изменений может теряться.

‌ Грязное чтение - транзакция читает данные, записанные параллельной незавершенной транзакцией. Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе.

‌ Неповторяемое чтение - транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией.

‌ Фантомное чтение - транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обраруживает, что набор строк,
удовлетворяющий условию, изменился из-за транзакции, завершившейся за это время.

‌ Аномалия сереализации - результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди


Непосредственно уровни изоляции:

| Уровень изоляции  | грязное чтение | неповторяемое чтение | фантомное чтение | аномалия сереализации |
| read uncommited   |       +        |          +           |        +         |          +            |
| read committed    |       -        |          +           |        +         |          +            |
| repeatable read   |       -        |          -           |        +         |          +            |
| serializable      |       -        |          -           |        -         |          -            |


https://www.baeldung.com/spring-transactional-propagation-isolation

#####
#####

 Какой уровень изоляции транзакций по умолчанию? 

в java уровень изоляции по умолчанию, определяется типом СУБД, для PostgreSQL это Read Committed

#####
#####

Транзакция может менять только то, что читает.
Исключение при одновременном изменении одной строки можно увидеть только на уровне изоляции serializable.
При таком исключении будет зафиксирована только первая транзакция, вторая уйдет в откат.

READ UNCOMMITTED

Указывает, что операторы могут читать строки, измененные другими транзакциями, но еще не зафиксированные.
Транзакции, работающие на уровне READ UNCOMMITTED, не создают общих блокировок, чтобы предотвратить другие транзакции.
Транзакции READ UNCOMMITTED также не блокируются эксклюзивными блокировками, которые не позволяют текущей транзакции читать строки, которые были изменены, но не зафиксированы другими транзакциями.

READ COMMITTED

Указывает, что операторы не могут считывать данные, которые были изменены, но не зафиксированы другими транзакциями.
Это предотвращает грязное чтение. Данные могут быть изменены другими транзакциями между отдельными операторами в рамках текущей транзакции,
что приводит к неповторяющимся операциям чтения или фантомным данным.

REPEATABLE READ

Уровень изоляции Repeatable Read видит только данные, зафиксированные до начала транзакции;
он никогда не видит ни незафиксированные данные, ни изменения, зафиксированные во время выполнения транзакции параллельными транзакциями.

Serializable
Уровень изоляции Serializable обеспечивает самую строгую изоляцию транзакций. Этот уровень эмулирует последовательное выполнение транзакций для всех зафиксированных транзакций; как если бы транзакции выполнялись одна за другой, последовательно, а не одновременно.

#####
#####

 Как уровень изоляции транзакций влияет на производительность? 

Чем выше уровень изоляции транзакций, тем больше накладные расходы в БД

#####
#####

 Как в java изменить уровень изоляции транзакций? 

- В чистом jdbc у класса Connection есть метод setTransactionIsolation
- В аннотации @Transactional(isolation = Isolation.READ_UNCOMMITTED)
- В TransactionManager метод

#####
#####

 Блокировки 

https://habr.com/ru/companies/otus/articles/506072/

Существует два способа управления параллелизмом:
- Повышение уровня изоляции транзакций
- Блокировка данных, которые нам нужны в данный момент

Уровень изоляции транзакций устанавливается для соедиения (connection) базы данных.
Тем самым он влияет на все инстукции в этом соединении.
Чем выше уровень изоляции тем больше накладных расходов на БД.

Однако есть возможность установливать блокировки непосредственно на данные при использовании JPA.
Существует два типа блокировок:
- Оптимистичные
- Писсимистичные


 Оптимистичные (Optimistic Locking) 

Optimistic Locking in JPA
https://www.baeldung.com/jpa-optimistic-locking

!!! Оптимистичные блокировки работают на уровне приложения. Блокировок на уровне БД не создается !!!
Как это работает:
Открывается транзакция - фиксируется версия сущности - выполняются операторы транзакции
- если версия сущности НЕ изменилась - транзакция фиксируется + инкрементится версия сущности
- если версия сущности изменилась - получаем OptimisticLockException

Для этого на сущность в БД необходимо установтить аннотацию @Version.
Обычно эта аннотация устанавливается на поле сущности с типом int, Integer, long, Long, short, Short, java.sql.Timestamp
При этом каждая транзакция, которая считывает данные, содержит значение поля версии @Version.
Прежде чем транзакция захочет выполнить обновление, она снова проверяет свойство версии.
Если за это время значение изменилось, создается исключение OptimisticLockException.
В противном случае транзакция фиксирует обновление и увеличивает значение свойства версии.
Оптимистическая блокировка основана на обнаружении изменений в сущностях путем проверки их атрибута версии.
Этот механизм подходит для приложений, которые выполняют гораздо больше операций чтения, чем обновления или удаления.

Режимы блокировок:

- OPTIMISTIC устанавливает оптимистическую блокировку чтения для всех сущностей, содержащих атрибут версии.
- OPTIMISTIC_FORCE_INCREMENT получает оптимистическую блокировку, такую же, как OPTIMISTIC, и дополнительно увеличивает значение атрибута версии.

Как установить оптимистическую блокировку:
- Доступна по умолчанию для сущностей с аннотацией @Version
- Query query = entityManager.createQuery() ... query.setLockMode(LockModeType.OPTIMISTIC_INCREMENT)
- entityManager.lock(student, LockModeType.OPTIMISTIC)
- Использовать аннотацию @NamedQuery на сущности


 Писсимистичные (Pessimistic Locking) 

Pessimistic Locking in JPA
https://www.baeldung.com/jpa-pessimistic-locking

!!! Писсимистичные блокировки работают на уровне базы данных !!!
Под капотом это 'SELECT … FOR UPDATE'

Есть два механизма управления параллелизмом:
- Установка надлежащего уровня изоляции транзакций
- Установка блокировки данных, которые нам нужны в данный момент.
  Уровень изоляции транзакций устанавливается на все соединение и соответственно увеличивает накладные расходы на каждую транзакцию.
  В противовес можно использовать 'писсимистичные блокировки', которые обеспечивают более гранулярные блокировки на уровне базы данных.
  Мы можем использовать пессимистическую блокировку, чтобы гарантировать,
  что никакие другие транзакции не смогут изменить или удалить зарезервированные данные.

Есть два типа блокировок:
- Экслюзивные (exclusive) - позволяет изменять и удалять зарезервированные данные.
- Общие (shared) - можем читать, но не писать данные, когда кто-то еще держит shared блокировку.

Получить экслюзивную блокировку можно через 'SELECT … FOR UPDATE'.

Режимы блокировок:
- PESSIMISTIC_READ позволяет нам получить общую блокировку (shared) и предотвратить обновление или удаление данных.
- PESSIMISTIC_WRITE позволяет нам получить эксклюзивную блокировку (exclusive) и предотвратить чтение, обновление или удаление данных.
- PESSIMISTIC_FORCE_INCREMENT работает так же, как PESSIMISTIC_WRITE, и дополнительно увеличивает атрибут версии версионного объекта.

Мы можем получить только одну блокировку за раз. Если это невозможно, генерируется PersistenceException.

Как установить пессимистическую блокировку блокировку:
- Аналогично как и оптимистическую.

Области блокировок:
Область определяет блокировать одну сущность или и сущность и все ее связи (вложенные связанные сущности)
Установить можно через - EntityManager, Query, TypedQuery or NamedQuery:

- PessimisticLockScope.NORMAL - блокирует только саму сущность. Также блокирует предков сущноси.
- PessimisticLockScope.EXTENDED - блокирует связанные сущности. При использовании @ElementCollection or @OneToOne, @OneToMany, etc. with @JoinTable.

#####
#####

 Индексы 


Полнотекстовый поиск — автоматизированный поиск документов, при котором поиск ведётся не по именам документов, а по их содержимому, всему или существенной части.

TID - tuple identifier, идентификатор строки/кортежа.



 B-tree 

Используется для сравнения:  '<' '>' '='
Полнотекстовый поиск: -

Основан на сбалансированном дереве.
Кореневая страница содержит диапозоны которые ссылкаются на промежуточные страницы, которые тоже содежат диаопозоны и они ссылаются на листья.
Листья содержан непосредственно TID-ы.


 HASH 

Используется для сравнения: '='
Полнотекстовый поиск: -

Очень быстро работает на прямое сравнение. Куда быстрее всех других индексов.
Работает аналогично hashMap.
Хранит ключ-значени: key: значение хеш функции value: TID (ссылка на строку в таблице)


 GiST 

Используется для: точки геолокации, полнотекстовый поиск
Полнотекстовый поиск: + (долгий на чтение, быстрый на запись)

Generalized Search Tree - Обобщенное поисковое дерево.
Это тоже сбалансированное дерево и в нем в каждом узле мы определяем некий предикат или условие, которое должно выполняться для всех узлов ниже.

Полнотекстовый поиск - в корне содержит все предикаты, в промежуточных страницах хранит части предикатов, которые ссылаются на листья с TID'ами.
В реальности используется сигнатурное дерево, где символам соответствует набор битов. Т.е. под капотом это битово дерево.
Возможно возникновение коллизий, когда разным наборам символов соответсвует один набор битов. Чревато двойным чтением.


 SP-GiSt 

Используется для: точки геолокации
Полнотекстовый поиск: -

Не сбалансированное дерево, SP - spacepatiotioned означает разделение пространства. Пространство - друмерная плоскость.
Используется только для индексации точек(на карте). Идея состоит в том, чтобы рекурсивно разделить области на четыре части(квадранта)
относительно центральной точки. Области не пересекаются

 GIN 

Используется для: полнотекстовый поиск
Полнотекстовый поиск: + (лучший для поиска по jsonb) (быстрое чтение, медленная запись)

Generalized Inverted Index - так называемый обратный индекс, хорошо подходит для полнотекстового поиска.
Харнит все строки содержащие то или иное слово поиска
Фактически хранит map: key: слово value: список TID
Быстро работает на чтение и медленно на записть,
т.к. для добавлении строки надо проийтись по всем значениям и добавить новое, при необходимости.


 BRIN 
Индекс блоковых зон. Block Range Index.
Используется для больших и отсортированных таблиц.
Основная идея в том чтобы отбросить ненужные страницы.
Не будет ошибкой рассматривать BRIN не как индекс в обычном понимании, а как ускоритель последовательного сканирования таблицы.

https://habr.com/ru/companies/postgrespro/articles/346460/

#####
#####

 Составные индексы 

Это индексы на два и более полей в таблице.
Составными могут быть только индексы: B-tree, GiST, GIN и BRIN.
Т.е. все кроме hash индексов.

Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному столбцу будет работать достаточно хорошо и сэкономит время и место. Индексы по более чем трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно.

#####
#####

 Функциональные индексы 

Или индексы по выражениям.

Пример:
SELECT * FROM test1 WHERE lower(col1) = 'value';
Индекс:
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));


#####
#####

 Как построить индекс без блокировки таблицы? 

Ключевое слово 'CONCURRENTLY ' CREATE INDEX CONCURRENTLY

#####
#####

Блокировки в PostgreSQL
https://www.youtube.com/watch?v=TCEvRlvi-fM
https://www.cybertec-postgresql.com/en/postgresql-understanding-deadlocks/

#####
#####

 Как сделать deadlock? 

1. Две паралельные транзакции одновляют две таблицы в разной последовательности.

Например, если транзакция 1 получает исключительную блокировку таблицы A, а затем пытается получить исключительную блокировку таблицы B, которую до этого получила транзакция 2, в данный момент требующая исключительную блокировку таблицы A, ни одна из транзакций не сможет продолжить работу.

BEGIN;
select * from bot.tst_1 for update ;
select pg_sleep(10);
select * from bot.tst_2 for update ;
COMMIT;

BEGIN;
select * from bot.tst_2 for update ;
select pg_sleep(10);
select * from bot.tst_1 for update ;
COMMIT;

2. Две паралельные транзакции обновляют одну строку! Пока не воспроизвел.

Как решать?
1. Выполять операторы sql последовательно, или не в рамках одной транзакции, или в обоих транзакциях в одном порядке.

#####
#####

 Как работает @transactional? 

https://habr.com/ru/articles/532000/
https://docs.spring.io/spring-framework/docs/4.1.5.RELEASE/spring-framework-reference/html/transaction.html
https://www.baeldung.com/spring-transactional-propagation-isolation

Под капотом работает так же как и раньше

Connection connection = DriverManager.getConnection(...)



#####
#####

 Свойства транзакции spring? @Transactional #

- transactionManager

- propagation - распространение - default Propagation.REQUIRED
    * REQUIRED - создание новой транзакции, если ее нет.
    * SUPPORTS - выполнять в текущей транзакции, выполнять без транзакции, если ее не существует.
    * MANDATORY - выполнять в текущей транзакции, выбросить исключение, если ее не существует
    * REQUIRES_NEW - создать новую транзакцию и приостановить текущую транзакцию, если она существует.
    * NOT_SUPPORTED - выполнить без транзакции, приостановить текущую транзакцию, если она существует.
    * NEVER - выполнить без транзакций, выбросить исключение, если транзакция существует.
    * NESTED - выполнить во вложенной транзакции, если текущая транзакция существует, в противном случае вести себя как REQUIRED

- Isolation
     ***

- readOnly - флаг, для которого можно установить значение true, если транзакция фактически доступна только для чтения, что позволяет проводить соответствующую оптимизацию во время выполнения.

- rollbackFor - Определяет ноль (0) или более классов исключений, которые должны быть подклассами Throwable, указывая, какие типы исключений должны вызывать откат транзакции.
- rollbackForClassName - аналогично по имени класса.

- noRollbackFor - противоположные по значение атрибуты. Какие исключения не должны вызывать откат транзакции.
- noRollbackForClassName - ***

#####
#####

 Чем отличается PreparedStatement от Statement 

Интерфейс Statement - Выполняет простой оператор SQL без параметров.

Интерфейс PreparedStatement - Выполняет подготовленный оператор SQL с входными параметрами или без них.

Интерфейс CallableStatement - предназначен для вызова хранимых процедур SQL.

#####
#####